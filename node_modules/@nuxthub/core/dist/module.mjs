import { writeFile, mkdir, readFile } from 'node:fs/promises';
import { argv } from 'node:process';
import { logger, createResolver, addServerScanDir, addServerImportsDir, addImportsDir, defineNuxtModule, addServerHandler, installModule } from '@nuxt/kit';
import { join } from 'pathe';
import { defu } from 'defu';
import { findWorkspaceDir } from 'pkg-types';
import { parseArgs } from 'citty';
import { stringifyTOML } from 'confbox';
import { execSync } from 'node:child_process';
import { joinURL } from 'ufo';
import { $fetch } from 'ofetch';
import { addCustomTab } from '@nuxt/devtools-kit';

const version = "0.7.19";

function generateWrangler(nuxt, hub) {
  const wrangler = {};
  if (hub.ai) {
    wrangler["ai"] = {
      binding: "AI"
    };
  }
  if (hub.analytics) {
    wrangler["analytics_engine_datasets"] = [{
      binding: "ANALYTICS",
      dataset: "default"
    }];
  }
  if (hub.blob) {
    wrangler["r2_buckets"] = [{
      binding: "BLOB",
      bucket_name: "default"
    }];
  }
  if (hub.kv) {
    wrangler["kv_namespaces"] = [{
      binding: "KV",
      id: "kv_default"
    }];
  }
  if (hub.database) {
    wrangler["d1_databases"] = [{
      binding: "DB",
      database_name: "default",
      database_id: "default"
    }];
  }
  return stringifyTOML(wrangler);
}

function addDevToolsCustomTabs(nuxt, hub) {
  nuxt.hook("listen", (_, { url }) => {
    hub.database && addCustomTab({
      category: "server",
      name: "hub-database",
      title: "Hub Database",
      icon: "i-ph-database",
      view: {
        type: "iframe",
        src: `https://admin.hub.nuxt.com/embed/database?url=${url}`
      }
    });
    hub.kv && addCustomTab({
      category: "server",
      name: "hub-kv",
      title: "Hub KV",
      icon: "i-ph-coin",
      view: {
        type: "iframe",
        src: `https://admin.hub.nuxt.com/embed/kv?url=${url}`
      }
    });
    hub.blob && addCustomTab({
      category: "server",
      name: "hub-blob",
      title: "Hub Blob",
      icon: "i-ph-shapes",
      view: {
        type: "iframe",
        src: `https://admin.hub.nuxt.com/embed/blob?url=${url}`
      }
    });
    hub.cache && addCustomTab({
      category: "server",
      name: "hub-cache",
      title: "Hub Cache",
      icon: "i-ph-lightning",
      view: {
        type: "iframe",
        src: `https://admin.hub.nuxt.com/embed/cache?url=${url}`
      }
    });
  });
}

const log$2 = logger.withTag("nuxt:hub");
const { resolve } = createResolver(import.meta.url);
function setupBase(nuxt, hub) {
  addServerScanDir(resolve("./runtime/base/server"));
  addServerImportsDir(resolve("./runtime/base/server/utils"));
  if (nuxt.options.dev) {
    addDevToolsCustomTabs(nuxt, hub);
  }
  nuxt.options.routeRules = nuxt.options.routeRules || {};
  nuxt.options.routeRules["/api/_hub/**"] = nuxt.options.routeRules["/api/_hub/**"] || {};
  nuxt.options.routeRules["/api/_hub/**"].csurf = false;
}
async function setupAI(nuxt, hub) {
  if (nuxt.options.dev && !hub.remote && !hub.projectKey) {
    return log$2.warn("`hubAI()` is disabled: link a project with `nuxthub link` to run AI models in development mode.");
  }
  if (nuxt.options.dev && !hub.remote && hub.projectKey) {
    try {
      await $fetch(`/api/projects/${hub.projectKey}`, {
        baseURL: hub.url,
        headers: {
          authorization: `Bearer ${hub.userToken}`
        }
      });
    } catch (err) {
      if (!err.status) {
        log$2.warn("`hubAI()` is disabled: it seems that you are offline.");
      } else if (err.status === 401) {
        log$2.warn("`hubAI()` is disabled: you are not logged in, make sure to run `nuxthub login`.");
      } else {
        log$2.error("`hubAI()` is disabled: failed to fetch linked project `" + hub.projectKey + "` on NuxtHub, make sure to run `nuxthub link` again.");
      }
      return;
    }
  }
  addServerScanDir(resolve("./runtime/ai/server"));
  addServerImportsDir(resolve("./runtime/ai/server/utils"));
}
function setupAnalytics(_nuxt) {
  addServerScanDir(resolve("./runtime/analytics/server"));
  addServerImportsDir(resolve("./runtime/analytics/server/utils"));
}
function setupBlob(_nuxt) {
  addServerScanDir(resolve("./runtime/blob/server"));
  addServerImportsDir(resolve("./runtime/blob/server/utils"));
  addImportsDir(resolve("./runtime/blob/app/composables"));
}
async function setupBrowser(nuxt) {
  const missingDeps = [];
  try {
    const pkg = "@cloudflare/puppeteer";
    await import(pkg);
  } catch (err) {
    missingDeps.push("@cloudflare/puppeteer");
  }
  if (nuxt.options.dev) {
    try {
      const pkg = "puppeteer";
      await import(pkg);
    } catch (err) {
      missingDeps.push("puppeteer");
    }
  }
  if (missingDeps.length > 0) {
    console.error(`Missing dependencies for \`hubBrowser()\`, please install with:

\`npx nypm i ${missingDeps.join(" ")}\``);
    process.exit(1);
  }
  addServerImportsDir(resolve("./runtime/browser/server/utils"));
}
function setupCache(nuxt) {
  nuxt.options.nitro = defu(nuxt.options.nitro, {
    storage: {
      cache: {
        driver: "cloudflare-kv-binding",
        binding: "CACHE",
        base: "cache"
      }
    },
    devStorage: {
      cache: {
        driver: "fs",
        base: join(nuxt.options.rootDir, ".data/cache")
      }
    }
  });
  addServerScanDir(resolve("./runtime/cache/server"));
}
function setupDatabase(_nuxt) {
  addServerScanDir(resolve("./runtime/database/server"));
  addServerImportsDir(resolve("./runtime/database/server/utils"));
}
function setupKV(_nuxt) {
  addServerScanDir(resolve("./runtime/kv/server"));
  addServerImportsDir(resolve("./runtime/kv/server/utils"));
}
function setupOpenAPI(nuxt) {
  nuxt.options.alias["#hub/openapi"] = nuxt.options.nitro?.experimental?.openAPI === true ? "nitropack/runtime/routes/openapi" : resolve("./runtime/openapi/server/templates/openapi");
  addServerScanDir(resolve("./runtime/openapi/server"));
}
async function setupRemote(_nuxt, hub) {
  let env = hub.remote;
  let branch = "main";
  if (String(env) === "true") {
    try {
      branch = execSync("git branch --show-current", { stdio: ["ignore", "pipe", "ignore"] }).toString().trim();
      env = branch === "main" ? "production" : "preview";
    } catch {
      log$2.warn("Could not guess the environment from the branch name, using `production` as default");
      env = "production";
    }
  }
  if (typeof hub.projectUrl === "function" && !hub.projectKey) {
    hub.projectUrl = hub.projectUrl({ env, branch });
  }
  if (hub.projectKey) {
    if (hub.projectSecretKey) {
      log$2.warn("Ignoring `NUXT_HUB_PROJECT_SECRET_KEY` as `NUXT_HUB_PROJECT_KEY` is set.");
    }
    const project = await $fetch(`/api/projects/${hub.projectKey}`, {
      baseURL: hub.url,
      headers: {
        authorization: `Bearer ${hub.userToken}`
      }
    }).catch((err) => {
      if (!err.status) {
        log$2.error("It seems that you are offline.");
      } else if (err.status === 401) {
        log$2.error("It seems that you are not logged in, make sure to run `nuxthub login`.");
      } else {
        log$2.error("Failed to fetch linked project on NuxtHub, make sure to run `nuxthub link` again.");
      }
      process.exit(1);
    });
    if (String(hub.remote) === "true") {
      env = branch === project.productionBranch ? "production" : "preview";
    } else {
      env = String(hub.remote);
    }
    if (typeof hub.projectUrl === "function") {
      hub.projectUrl = hub.projectUrl({ env, branch });
    }
    const adminUrl = joinURL(hub.url, project.teamSlug, project.slug);
    log$2.info(`Linked to \`${adminUrl}\``);
    log$2.info(`Using \`${env}\` environment`);
    hub.projectUrl = hub.projectUrl || (env === "production" ? project.url : project.previewUrl);
    if (!hub.projectUrl) {
      log$2.error(`No deployment found for \`${env}\`, make sure to deploy the project using \`nuxthub deploy\`.`);
      process.exit(1);
    }
    hub.env = env;
  }
  if (!hub.projectUrl) {
    log$2.error("No project URL defined, make sure to link your project with `nuxthub link` or add the deployed URL as `NUXT_HUB_PROJECT_URL` environment variable (if self-hosted).");
    process.exit(1);
  }
  if (!hub.projectKey && !hub.projectSecretKey && !hub.userToken) {
    log$2.error("No project secret key found, make sure to add the `NUXT_HUB_PROJECT_SECRET_KEY` environment variable.");
    process.exit(1);
  }
  log$2.info(`Using remote storage from \`${hub.projectUrl}\``);
  const remoteManifest = hub.remoteManifest = await $fetch("/api/_hub/manifest", {
    baseURL: hub.projectUrl,
    headers: {
      authorization: `Bearer ${hub.projectSecretKey || hub.userToken}`
    }
  }).catch(async (err) => {
    let message = "Project not found.\nMake sure to deploy the project using `nuxthub deploy` or add the deployed URL as `NUXT_HUB_PROJECT_URL` environment variable.";
    if (err.status >= 500) {
      message = "Internal server error";
    } else if (err.status === 401) {
      message = "Authorization failed.\nMake sure to provide a valid NUXT_HUB_PROJECT_SECRET_KEY or being logged in with `nuxthub login`";
    }
    log$2.error(`Failed to fetch remote storage: ${message}`);
    process.exit(1);
  });
  if (remoteManifest?.version !== hub.version) {
    log$2.warn(`\`${hub.projectUrl}\` is running \`@nuxthub/core@${remoteManifest?.version}\` while the local project is running \`@nuxthub/core@${hub.version}\`. Make sure to use the same version on both sides for a smooth experience.`);
  }
  Object.keys(remoteManifest?.storage || {}).filter((k) => hub[k] && !remoteManifest?.storage[k]).forEach((k) => {
    if (!remoteManifest?.storage[k]) {
      log$2.warn(`Remote storage \`${k}\` is enabled locally but it's not enabled in the remote project. Deploy a new version with \`${k}\` enabled to use it remotely.`);
    }
  });
  const availableStorages = Object.keys(remoteManifest?.storage || {}).filter((k) => hub[k] && remoteManifest?.storage[k]);
  if (availableStorages.length > 0) {
    logger.info(`Remote storage available: ${availableStorages.map((k) => `\`${k}\``).join(", ")} `);
  } else {
    log$2.fatal("No remote storage available: make sure to enable at least one of the storage options in your `nuxt.config.ts` and deploy new version before using remote storage. Read more at https://hub.nuxt.com/docs/getting-started/remote-storage");
    process.exit(1);
  }
}

const log$1 = logger.withTag("nuxt:hub");
function addBuildHooks(nuxt, hub) {
  if (!nuxt.options.dev && process.env.CF_PAGES && process.env.NUXT_HUB_PROJECT_DEPLOY_TOKEN && process.env.NUXT_HUB_PROJECT_KEY && process.env.NUXT_HUB_ENV) {
    hub.remote = false;
    nuxt.hook("modules:done", async () => {
      const { bindingsChanged } = await $fetch(`/api/projects/${process.env.NUXT_HUB_PROJECT_KEY}/build/${process.env.NUXT_HUB_ENV}/before`, {
        baseURL: hub.url,
        method: "POST",
        headers: {
          authorization: `Bearer ${process.env.NUXT_HUB_PROJECT_DEPLOY_TOKEN}`
        },
        body: {
          pagesUrl: process.env.CF_PAGES_URL,
          ai: hub.ai,
          analytics: hub.analytics,
          blob: hub.blob,
          browser: hub.browser,
          cache: hub.cache,
          database: hub.database,
          kv: hub.kv,
          bindings: hub.bindings
        }
      }).catch((e) => {
        if (e.response?._data?.message) {
          log$1.error(e.response._data.message);
        } else {
          log$1.error("Failed run build:before hook on NuxtHub.", e);
        }
        process.exit(1);
      });
      if (bindingsChanged) {
        log$1.box([
          "NuxtHub detected some changes in this project bindings and updated your Pages project on your Cloudflare account.",
          "In order to enable this changes, this deployment will be cancelled and a new one has been created."
        ].join("\n"));
        await new Promise((resolve) => setTimeout(resolve, 2e3));
        process.exit(1);
      }
    });
    nuxt.hook("build:error", async (error) => {
      await $fetch(`/api/projects/${process.env.NUXT_HUB_PROJECT_KEY}/build/${process.env.NUXT_HUB_ENV}/error`, {
        baseURL: hub.url,
        method: "POST",
        headers: {
          authorization: `Bearer ${process.env.NUXT_HUB_PROJECT_DEPLOY_TOKEN}`
        },
        body: {
          pagesUrl: process.env.CF_PAGES_URL,
          error: {
            message: error.message,
            name: error.name,
            stack: error.stack
          }
        }
      }).catch(() => {
      });
    });
    nuxt.hook("build:done", async () => {
      await $fetch(`/api/projects/${process.env.NUXT_HUB_PROJECT_KEY}/build/${process.env.NUXT_HUB_ENV}/done`, {
        baseURL: hub.url,
        method: "POST",
        headers: {
          authorization: `Bearer ${process.env.NUXT_HUB_PROJECT_DEPLOY_TOKEN}`
        },
        body: {
          pagesUrl: process.env.CF_PAGES_URL
        }
      }).catch((e) => {
        if (e.response?._data?.message) {
          log$1.error(e.response._data.message);
        } else {
          log$1.error("Failed run build:done hook on NuxtHub.", e);
        }
        process.exit(1);
      });
    });
  } else {
    nuxt.hook("nitro:build:public-assets", async (nitro) => {
      const hubConfig = {
        ai: hub.ai,
        analytics: hub.analytics,
        blob: hub.blob,
        browser: hub.browser,
        cache: hub.cache,
        database: hub.database,
        kv: hub.kv,
        bindings: hub.bindings
      };
      await writeFile(join(nitro.options.output.publicDir, "hub.config.json"), JSON.stringify(hubConfig, null, 2), "utf-8");
    });
  }
}

const log = logger.withTag("nuxt:hub");
const module = defineNuxtModule({
  meta: {
    name: "@nuxthub/core",
    configKey: "hub",
    version,
    docs: "https://hub.nuxt.com"
  },
  defaults: {},
  async setup(options, nuxt) {
    if (nuxt.options._generate) {
      log.error("NuxtHub is not compatible with `nuxt generate` as it needs a server to run.");
      log.info("To pre-render all pages: `https://hub.nuxt.com/docs/recipes/pre-rendering#pre-render-all-pages`");
      return process.exit(1);
    }
    const rootDir = nuxt.options.rootDir;
    const { resolve } = createResolver(import.meta.url);
    let remoteArg = parseArgs(argv, { remote: { type: "string" } }).remote;
    remoteArg = remoteArg === "" ? "true" : remoteArg;
    const runtimeConfig = nuxt.options.runtimeConfig;
    const hub = defu(runtimeConfig.hub || {}, options, {
      // Self-hosted project
      projectUrl: process.env.NUXT_HUB_PROJECT_URL || "",
      projectSecretKey: process.env.NUXT_HUB_PROJECT_SECRET_KEY || "",
      // Deployed on NuxtHub
      url: process.env.NUXT_HUB_URL || "https://admin.hub.nuxt.com",
      projectKey: process.env.NUXT_HUB_PROJECT_KEY || "",
      userToken: process.env.NUXT_HUB_USER_TOKEN || "",
      // Remote storage
      remote: remoteArg || process.env.NUXT_HUB_REMOTE,
      remoteManifest: void 0,
      // Local storage
      dir: ".data/hub",
      // NuxtHub features
      ai: false,
      analytics: false,
      blob: false,
      browser: false,
      cache: false,
      database: false,
      kv: false,
      // Other options
      version,
      env: process.env.NUXT_HUB_ENV || "production",
      openapi: nuxt.options.nitro.experimental?.openAPI === true,
      // Extra bindings for the project
      bindings: {
        hyperdrive: {}
      }
    });
    runtimeConfig.hub = hub;
    if (hub.remote && !["true", "production", "preview"].includes(String(hub.remote))) {
      log.error("Invalid remote option, should be `false`, `true`, `'production'` or `'preview'`");
      hub.remote = false;
    }
    if (hub.url !== "https://admin.hub.nuxt.com") {
      log.info(`Using \`${hub.url}\` as NuxtHub Admin URL`);
    }
    if (nuxt.options.dev) {
      addServerHandler({
        route: "/api/_hub",
        middleware: true,
        handler: resolve("./runtime/cors.dev")
      });
    }
    setupBase(nuxt, hub);
    setupOpenAPI(nuxt);
    hub.ai && await setupAI(nuxt, hub);
    hub.analytics && setupAnalytics();
    hub.blob && setupBlob();
    hub.browser && await setupBrowser(nuxt);
    hub.cache && setupCache(nuxt);
    hub.database && setupDatabase();
    hub.kv && setupKV();
    if (nuxt.options._prepare) {
      return;
    }
    addBuildHooks(nuxt, hub);
    nuxt.options.nitro.rollupConfig = nuxt.options.nitro.rollupConfig || {};
    nuxt.options.nitro.rollupConfig.plugins = [].concat(nuxt.options.nitro.rollupConfig.plugins || []);
    nuxt.options.nitro.rollupConfig.plugins.push({
      name: "nuxthub-rollup-plugin",
      resolveId(id) {
        if (id.startsWith("cloudflare:")) {
          return { id, external: true };
        }
        return null;
      }
    });
    nuxt.options.nitro.experimental = nuxt.options.nitro.experimental || {};
    nuxt.options.nitro.experimental.asyncContext = true;
    nuxt.options.nitro.unenv = nuxt.options.nitro.unenv || {};
    nuxt.options.nitro.unenv.external = nuxt.options.nitro.unenv.external || [];
    if (!nuxt.options.nitro.unenv.external.includes("node:async_hooks")) {
      nuxt.options.nitro.unenv.external.push("node:async_hooks");
    }
    if (hub.remote) {
      await setupRemote(nuxt, hub);
      return;
    }
    if (!nuxt.options.nitro.unenv.external.includes("node:stream")) {
      nuxt.options.nitro.unenv.external.push("node:stream");
    }
    if (!nuxt.options.dev) {
      let preset = nuxt.options.nitro.preset = nuxt.options.nitro.preset || "cloudflare-pages";
      preset = String(preset).replace("_", "-");
      if (preset !== "cloudflare-pages" && preset !== "cloudflare-module") {
        log.error("NuxtHub is only compatible with the `cloudflare-pages` and `cloudflare-module` presets.");
        process.exit(1);
      }
      nuxt.options.nitro.commands = nuxt.options.nitro.commands || {};
      nuxt.options.nitro.commands.preview = "npx nuxthub preview";
      nuxt.options.nitro.commands.deploy = "npx nuxthub deploy";
    }
    if (nuxt.options.dev) {
      log.info(`Using local storage from \`${hub.dir}\``);
      const hubDir = join(rootDir, hub.dir);
      try {
        await mkdir(hubDir, { recursive: true });
      } catch (e) {
        if (e.errno === -17) ; else {
          throw e;
        }
      }
      const workspaceDir = await findWorkspaceDir(rootDir);
      const gitignorePath = join(workspaceDir, ".gitignore");
      const gitignore = await readFile(gitignorePath, "utf-8").catch(() => "");
      if (!gitignore.includes(".data")) {
        await writeFile(gitignorePath, `${gitignore ? gitignore + "\n" : gitignore}.data`, "utf-8");
      }
      const needWrangler = Boolean(hub.ai || hub.analytics || hub.blob || hub.database || hub.kv);
      if (needWrangler) {
        const wranglerPath = join(hubDir, "./wrangler.toml");
        await writeFile(wranglerPath, generateWrangler(nuxt, hub), "utf-8");
        nuxt.options.nitro.cloudflareDev = {
          persistDir: hubDir,
          configPath: wranglerPath,
          silent: true
        };
        await installModule("nitro-cloudflare-dev");
      }
      nuxt.options.nitro.plugins = nuxt.options.nitro.plugins || [];
      nuxt.options.nitro.plugins.push(resolve("./runtime/ready.dev"));
    }
  }
});

export { module as default };
